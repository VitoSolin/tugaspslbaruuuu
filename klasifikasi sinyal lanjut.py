# -*- coding: utf-8 -*-
"""db clasification

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dJKJKyrDL4lzZ9ZgJMROw-FT2THCjLFY
"""

# =============================
# 1. Setup Environment in Colab
# =============================
from google.colab import drive
import numpy as np
import scipy.io.wavfile as wav
import scipy.signal as sp_signal
import matplotlib.pyplot as plt

# Mount Google Drive
drive.mount('/content/drive')

# =============================
# 2. Load Audio from Google Drive Path
# =============================

input_audio_path = "/content/drive/MyDrive/realtest.wav" 
rate, data = wav.read(input_audio_path)

# Convert stereo to mono if needed
if data.ndim > 1:
    data = data[:, 0]

data = data / np.max(np.abs(data))  # normalize

# =============================
# 3. FIR Bandpass Filter Design - Updated to 80-4000 Hz
# =============================
low_cutoff = 30
high_cutoff = 4000
numtaps = 101
fir_coeff = sp_signal.firwin(numtaps, [low_cutoff, high_cutoff], pass_zero=False, fs=rate)
filtered = sp_signal.lfilter(fir_coeff, 1.0, data)

# =============================
# 4. FFT Function
# =============================
def compute_fft(sig, rate):
    N = len(sig)
    freq = np.fft.rfftfreq(N, d=1/rate)
    magnitude = np.abs(np.fft.rfft(sig))
    return freq, magnitude

# =============================
# 5. Decibel Calculation Function
# =============================
def calculate_db(signal):
    """Calculate decibel level of a signal segment"""
    # Avoid log of zero by adding a small value
    epsilon = 1e-10

    # Calculate power of signal
    power = np.mean(signal**2)

    # Convert to decibels
    # Reference level is full scale (1.0 after normalization)
    db = 10 * np.log10(power + epsilon)

    return db

# =============================
# 6. Classification Function (Using Decibels)
# =============================
def classify_by_decibel(signal, rate, segment_duration=0.2):
    segment_size = int(segment_duration * rate)
    num_segments = len(signal) // segment_size

    labels = []
    db_levels = []

    # Define thresholds for classification (in dB) - adjust as needed
    quiet_threshold = -35   # Below this is considered quiet
    moderate_threshold = -20  # Below this is moderate, above is noisy

    for i in range(num_segments):
        segment = signal[i * segment_size : (i + 1) * segment_size]

        # Calculate dB level for segment
        db_level = calculate_db(segment)
        db_levels.append(db_level)

        # Classify based on dB level
        if db_level < quiet_threshold:
            labels.append("Hening")
        elif db_level < moderate_threshold:
            labels.append("Sedang")
        else:
            labels.append("Bising")

    return labels, db_levels

# =============================
# 7. Classification Before/After Filtering
# =============================
labels_orig, db_levels_orig = classify_by_decibel(data, rate)
labels_filt, db_levels_filt = classify_by_decibel(filtered, rate)

# =============================
# 8. Plot Comparison
# =============================
x = np.arange(len(labels_orig))

plt.figure(figsize=(15, 6))
plt.plot(x, db_levels_orig, marker='o', label='Original Signal', color='gray')
plt.plot(x, db_levels_filt, marker='o', label='Filtered Signal', color='blue')

# Add classification labels to plot
for i in range(len(labels_orig)):
    plt.text(i, db_levels_orig[i], labels_orig[i], fontsize=8, color='gray', ha='center', va='bottom', rotation=45)
    plt.text(i, db_levels_filt[i], labels_filt[i], fontsize=8, color='blue', ha='center', va='top', rotation=45)

# Add horizontal threshold lines
plt.axhline(-35, color='green', linestyle='--', label='Hening Threshold (-35 dB)')
plt.axhline(-20, color='red', linestyle='--', label='Sedang Threshold (-20 dB)')

plt.title("Comparison of Decibel-Based Classification (Before vs After Filtering)")
plt.xlabel("Segment #")
plt.ylabel("Sound Level (dB)")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# =============================
# 9. Distribution of Classification Results
# =============================
# Plot classification
def plot_classification_distribution(labels, title):
    """Plots the distribution of classification labels."""
    unique_labels, counts = np.unique(labels, return_counts=True)


plot_classification_distribution(labels_orig, "Noise Classification Distribution (Original Signal)")
plot_classification_distribution(labels_filt, "Noise Classification Distribution (Filtered Signal)")

# =============================
# 10. FFT Spectrum Comparison
# =============================
freq_orig, fft_orig = compute_fft(data, rate)
freq_filt, fft_filt = compute_fft(filtered, rate)

fft_orig_norm = fft_orig / np.max(fft_orig)
fft_filt_norm = fft_filt / np.max(fft_filt)

plt.figure(figsize=(15, 6))
plt.plot(freq_orig, fft_orig_norm, label='Original Signal', color='gray', alpha=0.7)
plt.plot(freq_filt, fft_filt_norm, label='Filtered Signal', color='blue', linewidth=2)
plt.axvline(30, color='green', linestyle='--', label='Low Cutoff (30 Hz)')
plt.axvline(4000, color='red', linestyle='--', label='High Cutoff (4000 Hz)')
plt.title("Frequency Spectrum Comparison: Before vs After FIR Filtering")
plt.xlabel("Frequency (Hz)")
plt.ylabel("Normalized Magnitude")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# =============================
# 11. Save Output and Download
# =============================
filtered_int16 = np.int16(filtered / np.max(np.abs(filtered)) * 32767)
output_filename = "filtered_output.wav"
#wav.write(output_filename, rate, filtered_int16)


# =============================
# 12. Generate Summary Report
# =============================
print("===== Audio Analysis Summary =====")
print(f"Sample Rate: {rate} Hz")
print(f"Duration: {len(data)/rate:.2f} seconds")
print(f"Segments Analyzed: {len(labels_orig)}")

# Count classifications
orig_counts = {label: labels_orig.count(label) for label in set(labels_orig)}
filt_counts = {label: labels_filt.count(label) for label in set(labels_filt)}

print("\nOriginal Signal Classification:")
for label, count in orig_counts.items():
    print(f"  - {label}: {count} segments ({count/len(labels_orig)*100:.1f}%)")

print("\nFiltered Signal Classification:")
for label, count in filt_counts.items():
    print(f"  - {label}: {count} segments ({count/len(labels_filt)*100:.1f}%)")

print("\nAverage dB level (Original): {:.2f} dB".format(np.mean(db_levels_orig)))
print("Average dB level (Filtered): {:.2f} dB".format(np.mean(db_levels_filt)))